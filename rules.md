# 程序设计的一些原则

## 关于失败的重试
对于前端可以重试的，系统不稳定时直接抛出错误；
对于前端不能重试的，系统暂时不可用时，通过落库、消息等将失败的处理存储起来，并进行异步重试。

## 关于重复消息的处理
对于消息的重复消费问题，需要消费端做对应的幂等处理。所谓的幂等处理，就是处理多次与处理一次的效果是一样的。有两种方案可以对消息进行幂等处理：

1. 可以通过记录的状态来识别重复消息，比如订单在之前前状态为“未支付”，接收到支付消息後，更新状态为“已支付”。再次接收到重复的支付消息时，查看订单的状态为已支付，则忽略掉该消息。

2. 通过全局唯一的字段来识别重复消息，这要求消息中必须带有的唯一标识字段，如订单ID等。这时可以将已处理消息的唯一标识字段保存起来，当有新消息来的时候，通过比对唯一标识字段，判断消息是否已消费。保存已消费消息的唯一标识字段的途径有多种，可以是关系数据库中的唯一健，也可以是持久化缓存中的key。为了防止保存的key过多，可以根据消息的有效期（消息不会保存太久），定时地去清除保存的key。

## 关于消息的位移提交与失败重试
Kafka
对于消息，如果一次获取多条，那么如果其中几条消费失败，如何设置消费位移？
Kafka不支持消息的失败重试，如果在消费消息失败时，


## 关于race condition
对于需要加锁的操作，对应的检验，需要放在加锁区域中进行。否则，很可能最开始检查条件通过了，但在获取锁之后，已经有别的线程更新所检查的值，此时条件已经不符合了。放在加锁区域中检查，可以保证此时没有别的线程会更改所检查的值（因为其他线程获取不到锁）。

## 关于事务与锁的顺序
锁必须在事务的外面，即：
> 1. 加锁
> 2. 开启事务
> 3. 执行业务逻辑
> 4. 提交或回滚事务
> 5. 释放锁
因为如果锁在事务里面的话，在事务提交或回滚前，就释放了锁，那么就存在对一条数据的并发修改，这样就可能存在错误。特别是将旧值读入内存，然后计算出新值并更新数据库的情况，此时多个线程可能读入同一旧值，然后计算得到不同旧值并更新，这样的更新就会相互覆盖，造成错误。
