# 程序设计的一些原则

## 关于接口处理失败的重试
- 对于前端可以重试的业务场景
  - 场景举例：如用户在长期存在的页面领取权益，领取失败时用户可以尝试再次领取。
  - 推荐处理方式：后端在处理接口的业务逻辑时，因系统不稳定时导致的失败，可以直接返回给前端错误，后续由用户在前端重试。

- 对于前端不能重试的业务场景
  - 场景举例：如注册成功时给用户发放某项权益，由于注册成功是一次性的，所以前端重试发放权益。
  - 系统若因抖动导致处理失败的话，可以先将调用上下文保存起来，并返回给前端成功。可以通过将调用上下文落库，或向消息引擎发送消息等方式保存调用失败的相关信息，并在後续进行异步重试，确保最终处理成功。

## 关于重复消息的处理
对于消息的重复消费问题，需要消费端做对应的幂等处理。所谓的幂等处理，就是处理多次与处理一次的效果是一样的。有两种方案可以对消息进行幂等处理：

1. 通过记录的状态来识别重复消息。比如订单的状态为“未支付”，接收到支付消息後，更新状态为“已支付”。再次接收到重复的支付消息时，发现订单的状态为已支付，则忽略掉该消息。

2. 通过全局唯一的字段来识别重复消息，这要求消息中必须带有的唯一标识字段，如订单ID等。这时可以将已处理消息的唯一标识字段保存起来，当有新消息来的时候，通过比对唯一标识字段，判断消息是否已消费。保存已消费消息的唯一标识字段的途径有多种：
  - 作为唯一健保存在数据库中：每次处理消息前，先将消息中的唯一字段插入表中，若出现唯一健冲突，则表明消息已被处理过。
  - 将唯一字段作为key保存在持久化缓存中：与保存在数据库中类似，根据缓存中是否存在该key，确定消息是否被重复处理。
  为了避免保存的key过多造成存储的浪费，可以根据消息的有效期（消息在Broker端一般不会永久保存下去），在确定消息已不会再次发送至消费者端後，定时地去清除数据库中保存的key，或者给缓存中的key设置有效期。

## 关于消息的位移提交与失败重试
Kafka
对于消息，如果一次获取多条，那么如果其中几条消费失败，如何设置消费位移？
Kafka不支持消息的失败重试，如果在消费消息失败时，


## 关于 race condition（竞争条件）
对于存在并发更新的字段，为了防止出现写错误，在更新对需要对其加锁，以便串行化更新。很多场景下，在堆字段进行更新前会做检测，根据检测结果采取不同的动作。**这里的检测，需要与後续的操作一样，放在加锁区域中进行，即先加锁再对字段做检测**。否则，就会出现所谓的race condition，即在检测时刻与根据检测结果执行某项操作之间，被检测的字段值被其他线程并发改变了，从而导致执行操作时先前检测的条件已经不符合了。

比如，我们查看用户的状态字段S，若其值为0，则给他发放一项新人权益；若其值为1，则不发放。我们时刻A检测用户的状态S=0，然後在时刻B将状态S更新为1，并给用户发放新人权益。但是在时刻A与B之间，有另外一个线程也检测到用户的状态S=0，然後也给用户发放了新人权益，从而导致发了两次。正确的做法应该是，先对该字段加锁，然後在加锁区域中检测其值，并据字段值进行相应的操作。这样可确保在检测与後续的操作之间，没有别的线程会并发地进行同一操作（因为其他线程获取不到锁）。

## 关于事务与锁的顺序
锁必须在事务的外面，即：
> 1. 加锁
> 2. 开启事务
> 3. 执行业务逻辑
> 4. 提交或回滚事务
> 5. 释放锁

因为如果锁在事务里面的话，在事务提交或回滚前释放了锁，那么当前线程的更改提交或回滚前，就会有其他线程来更改同一条数据，从而存在对一条数据的并发更改，造成错误。特别是将旧值读入内存，然后计算出新值并更新数据库的情况，此时多个线程可能读入同一旧值，然后计算得到不同的值并更新，这样的更新就会存在相互覆盖的错误。
