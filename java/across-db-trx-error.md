# 一次跨库事务问题排查记录

## 问题描述

最近有个线上应用，偶现跨库事务的错误，频率时高时低。

该应用底层所用的是 **分库分表的逻辑库**，用户的 userId 作为 sharding key。因此， **用户相关的记录，都按 userId 路由存储到不同的分表中；但同时还有一些数据量很小的业务配置信息表，是以单库单表的形式存放在某个物理库上**。

## 原因定位

由于错误不是必现，也就难以debug。只能去观察出错信息，review代码，查看可能出现问题的代码逻辑。

应用在使用Spring的事务时，声明式和编程式两种方式都有。我们知道，编程式事务（为了细粒度控制事务的边界，我们用的是 `TransactionStatus transactionStatus = this.transactionManager.getTransaction(this.transactionDefinition);` 这种方式）使用不小心的话，可能出现请求结束但事务未完结（没有提交或回滚）的情况。

因此一开始，把所有用到这类编程式事务的地方，都一遍遍地做了review，并且加了一些代码做check，并加了日志。但是在怀疑可能有bug的地方，并没有出现有问题的日志打点。

後来查看日志中的异常信息，发现在调用链路中， **先根据 userId 连接了某个分库（物理库），而後又需要查询配置信息，而配置信息是在某个特定的物理库上。这样就出现同一个事务中，需要连接两个不同物理库的情况，因此就报了跨库事务的错误**。

## 解决方案

问题定位到了，接下来找解决方案。

一种途径是把查询配置信息表的操作，移到事务之外。这个点在最初编码时就有注意到。在业务开始前，需要查询配置表中的信息，做一次校验。因为考虑到如果跟後面针对特定 userId 的操作放在一个事务里，会出现跨库问题，所以特意将其放在了事务外面。只是业务逻辑比较复杂，而且是将不同人写的业务代码，整合在一个事务操作中，所以没料到在其他地方，仍有从单库单表中查询配置信息的逻辑。

但根据业务逻辑的需要，有些代码块中查询配置信息时，事务还不能结束，也就无法按上述方案执行。

Spring事务中有个 **传播属性**，可以根据需要进行配置。它的应用场景一般为： *当线程中已经存在一个事务上下文时，如果遇到一个事务性方法（a transactional method），通过设置可选择加入已有的事务，还是新开一个事务，甚至是不在事务中执行*。

在事务的传播属性中，有个属性值是`NOT_SUPPORTED`，即不支持事务。它表示当前方法不要在事务中运行，如果调用者事先已在事务中，则会暂停该事务，然后执行当前方法。 __只要将查询配置信息表的方法，传播属性设置`NOT_SUPPORTED`，这样就不在事务中执行了__。比如，如果用声明式事务，配置代码如下：
```
@Transactional(propagation = Propagation.NOT_SUPPORTED)
```
这样改好后测试、发布，跨库错误果然消失，终于解决了问题。

## 其他疑点

*为什么这个跨库问题是偶发而不是必现呢？*

Ans：如果 userId 所在的分库，与配置信息表所在的库是同一个，则不会出现跨库错误，否则会报错。


*我们有16个分库，而配置信息表只在其中一个分库中，理论上出现跨库的频率会很高，为什么之前好像没怎么报错，频率没那么高呢？*

Ans：是因为我们对配置信息加了缓存，一旦缓存命中，就不去查询数据库，也就不会涉及跨库。但是由于最近有新业务上线，缓存的实际使用量已超出了配额，所以配置信息在缓存中经常被冲掉，因此出现跨库的频率高了很多。
