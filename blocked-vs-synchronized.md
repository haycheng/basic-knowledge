# IO

## 同步、异步 与 阻塞、非阻塞

- 同步（synchronized）与异步（asynchronized），是描述被调用方的，表示被调用方法立刻去执行任务，还是后续才执行。
- 阻塞（blocked）与非阻塞（non-blocked），是描述调用方的，表示调用方会阻塞在被调用方法那里，还是立刻从被调用方法中返回。我理解的阻塞与非阻塞，有两种区分方法。一是按“从进入方法体执行，到从方法体中返回之间的时间”的长度来区分的，但是这个长度并没有严格的标准，没有说超过某个时间长度就叫做阻塞，所以这个定义是模糊的。还有一种区分方法是，从方法体中返回时，若已经完成了任务的所有工作量则是阻塞的，否则为非阻塞的。

  - 阻塞：调用方调用某个方法后，若方法执行需要较长时间，则会看到调用方线程被阻塞在那里（调用方线程在方法体内部执行某段逻辑），直到方法执行完返回。
  - 非阻塞：调用某个方法后，马上就返回了。可能是任务很简单，一会儿就执行完了，也可能只是在方法内部提交了任务，并没有马上执行（后续会执行），所以会很快返回。
  - 同步：即被调用的方法立刻去执行指定的任务。一般会在当前线程中执行任务，执行完返回；另一种情况是，可能会new出几个线程去执行该任务，当前线程等待这些线程执行完再返回。
  - 异步：一种可能是在被调用的方法中new出一个新线程，由新线程执行所需的任务（如果新线程马上执行任务，应该也算同步？），当前线程不等新线程执行完就立刻返回了。还有一种情况是，在被调用的方法中，将任务加到了任务队列中，后续再异步地去执行该任务。

### 同步、阻塞的情况
在被调用的方法中立刻去执行任务（**同步**），并且执行任务需要花较长时间，等执行完毕后才返回（**阻塞**）。这种情况一般是在当前线程中去执行任务。（问题：如果执行任务所需时间很短，是不是可以算作非阻塞？）
### 同步、非阻塞的情况
在被调用的方法中立刻去执行任务（**同步**），并且不等任务执行完，而是立刻返回（**非阻塞**）。这种情况一般是当前线程（即调用方所在的线程）在方法中启动新的线程去执行任务，不等任务执行完自己就返回了。
### 异步、阻塞的情况
并不在被调用的方法中立刻去执行任务（**异步**）（可能是提交该任务到任务队列，后续再执行），当前线程还耗在那里不返回（**阻塞**）（不知在那里干什么）。这种情况比较少见。
### 异步、非阻塞的情况
并不在被调用的方法中立刻去执行任务（**异步**），当前线程也立刻返回（**非阻塞**）。这种情况比较常见，将任务成功提交至任务队列后，当前线程就返回了，后续由其他线程在特定时间去执行这些任务。

通常来说，同步执行任务的方法与阻塞常一起出现，而异步与非阻塞常一起出现。

## 几种IO缩写
- BIO：Blocking IO，即阻塞IO。在Java中，BIO的实现位于java.io包下。
- NIO：有两种含义。一是 Non-blocking IO，即非阻塞IO；另一种是 New IO，是Java 1.4 开始引入的一种新的IO方式，在java.nio包下。Java 的 New IO 是面向块的IO，而Java 1.4之前的IO是面向流的。New IO只支持阻塞式调用。
- AIO：Asynchronized IO，即异步IO。

## 几种IO模型
### 阻塞IO
调用时会被阻塞，并交出CPU使用权。直至IO所需数据准备完成，才会从调用中返回。

### 非阻塞IO
无论数据是否准备好，调用时都会立即返回。根据返回结果判断数据是否准备好，若准备好则进行下一步操作，否则再次调用并查看返回结果。此种方式称为轮询（round robin），会占用较多的CPU资源。

### 多路复用IO
用一个线程，管理多个IO操作。与非阻塞方式类似，该线程也是通过一个函数，去轮询是否有某个IO数据准备好了。该轮询函数是阻塞式的，无准备好的数据时会一直阻塞，若数据准备好则返回，然后对其进行相应的处理。

### 信号驱动IO


### 异步IO


**参考文档**
1. [几种IO的比较](https://github.com/hollischuang/toBeTopJavaer/blob/master/basics/java-basic/bio-vs-nio-vs-aio.md)

