# 消息系统(messaging system)学习

## 消息系统的作用
- 应用之间解耦：下游系统无需直接依赖上游的业务系统，而只需依赖消息系统，避免对接不同上游系统接口带来的复杂性。
- 削峰填谷：将上游的流量洪峰，通过消息系统进行缓冲，避免给下游系统造成过大压力，压垮下游系统。同时在上游流量很低的情况下，消息系统中也有堆积的消息供下游系统消费，不至于浪费下游系统的服务能力。
- 整合异构系统：如线上库的数据同步到线下的数据仓库中。
- 同步转异步：对于无需同步完成的操作（如业务日志收集，用户注册成功後发送邮件，MySQL主备库之间的数据同步，某一业务操作通过消息通知多个下游系统等），可以通过消息系统异步执行，加速业务主流程的完成。

## 消息模型
#### 两种传统的消息模型
- 队列（queue）模型：也叫点对点（point-to-point）模型。该模型的特点是，一个队列中的所有消息，会被一个消费者消费，且只能被该消费者消费一次。
- 主题（topic）模型：也叫发布-订阅（publish-subscribe）模型。该模型的特点是，一个主题的消息，可以被多个订阅了该主题的消费者消费，且每个消费者都会消费该主题下的全量消息。

另外，传统的消息系统中，消费者一般都是单个的消费实例，即消费者仅是一个线程，这与Kafka的消费者组有所区别。

#### Kafka中的消息模型
Kafka中的消息模型，类似于传统的主题模型，但其扩展了消费者的概念，引入了消费者组（Consumer Group）。消费者组下包括多个消费者实例，整个消费者组作为一个消费者，共同消费所订阅主题下的所有消息。

## 消息系统的衡量指标
- 高性能：对于消息的生产与消费，以及其他的操作，都保持处理速度快，吞吐量高。
- 高可靠性：消息不丢失。更高的要求是消息不重复。
- 消息的有序性：对于按一定顺序产生、且业务逻辑上具有先後之分的一组消息，能够保证按产生顺序进行消费。如属于同一购买订单的创建、支付、确认收货3个消息，需要保证按消息产生的顺序消费，否则就会产生错误。
- 消息堆积能力：是消息系统削峰填谷功能的前提。优秀的消息系统，需具备较大的消息堆积能力，同时在堆积较多消息时系统的性能不能明显下降。目前RocketMQ在消息堆积超过阈值後，系统吞吐量会有较大下降。
- 实时性：消息能够低延迟、准实时的进行传递。
- 事务消息的支持
- 易于排错

## 消息系统的架构
消息系统由服务端和客户端组成。

服务端包括存储、管理消息的Broker服务器，以及进行集群管理的服务器，後者依不同的实现而有所不同，如Kafka中是ZooKeeper，而RocketMQ中自建了称为NameServer的系统。

客户端则包括主要用于向消息系统提交其产生的消息的Producer，以及主要用于从消息系统获取并消费消息的Consumer。

## 关于重复消息的处理
消息的产生和消费两个阶段，都存在消息重复的问题。

#### 消息产生阶段的重复
由于网络的不可靠性，Producer产生的一条消息可能多次到达Broker端。Broker需要有机制对其进行去重，但成本比较大。目前RocketMQ不支持产生阶段的消息去重。

#### 消息消费阶段的重复
目前Kafka和RocketMQ都无法保证消费阶段的消息重复，需要消费应用自己控制，对消费做幂等处理。所谓的幂等处理，就是处理多次与处理一次的效果是一样的。有两种方案可以对消息进行幂等处理：

- 通过记录的状态处理重复消息。比如订单的状态为“未支付”，接收到支付消息後，更新状态为“已支付”。再次接收到重复的支付消息时，发现订单的状态为已支付，则忽略掉该消息。

- 通过全局唯一的字段来识别重复消息，这要求消息中必须带有的唯一标识字段，如订单ID等。这时可以将已处理消息的唯一标识字段保存起来，当有新消息来的时候，通过比对唯一标识字段，判断消息是否已消费。保存已消费消息的唯一标识字段的途径有多种：
  - 作为唯一健保存在数据库中：每次处理消息前，先将消息中的唯一字段插入表中，若出现唯一健冲突，则表明消息已被处理过。
  - 将唯一字段作为key保存在持久化缓存中：与保存在数据库中类似，根据缓存中是否存在该key，确定消息是否被重复处理。
  为了避免保存的key过多造成存储的浪费，可以根据消息的有效期（消息在Broker端一般不会永久保存下去），在确定消息已不会再次发送至消费者端後，定时地去清除数据库中保存的key，或者给缓存中的key设置有效期。

（另外从资料上看到说，消费端可通过主动拉的方式保证消息不重复，但消费端需要解决分布式协调分配队列问题。不太清楚具体原理。）

## Kafka与RocketMQ的比较
- **消息的持久化**：Kafka和RocketMQ都是将消息顺序存储在文件中，因为是顺序写盘，所以速度比较快。
- **消费端获取消息的方式**：分服务端push和消费端pull两种方式。目前RocketMQ默认是消费端通过长连接轮询的方式去服务端pull消息，消息延迟在几毫秒；也支持push方式。
- **消息过滤**：两者都支持服务端的消息过滤。Kafka支持通过正则表达式订阅多个主题，RocketMQ不支持正则表达式，但支持根据topic下的tag进一步过滤。
- **消息重试**：即对于处理失败的消息，Broker端继续存储该消息，并按设定在恰当的时刻再次给消费者消费。目前Kafka不支持消息重试，但RocketMQ支持。RocketMQ消息重试的次数，以及两次重试的时间间隔有限制。（对于顺序消息，若消息消费失败，则当前队列将挂起，等待下次消息重试。）
- **消息定位**：RocketMQ中支持通过设置消息的 Message Key（如设置成订单ID），方便在排查问题时快速定位消息。
- **Message Size**：RocketMQ不推荐应用发送超过16K的消息。如果消息比较大，可以对Producer端进行配置，在发送前对超过一定大小（默认为4K）的消息进行压缩，然後消息到达Consumer前会自动解压，该过程对用户透明。如果压缩过後消息仍然较大，则最好对消息进行拆分，因为RocketMQ通信层没有对大的请求做优化，大的请求传递可能会导致网络层的Buffer异常，且其服务器存储是一个LRU CACHE系统，过大的消息会占用较多Cache，影响其他消息的Cache命中率。


## 相关名词
- MOM：Message-Oriented Middleware，面向消息的中间件，即消息中间件，它实现了一整套消息系统的功能，如Kafka、RocketMQ。
- JMS：Java Messaging Service，Java消息服务，是Java制定的消息服务的规范，各产商可以遵循该规范去实现及使用消息系统，从而降低沟通成本。

**参考资料：**
1. [Introduction to Messaging Systems](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessagingComponentsIntro.html)
1. [Messaging Systems: An Introduction - Oracle Docs](https://docs.oracle.com/cd/E26576_01/doc.312/e24949/messaging-systems-introduction.htm#GMTOV00025)

