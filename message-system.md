# 消息系统(messaging system)学习

## 消息模型
### 两种传统的消息模型
- 队列（queue）模型：也叫点对点（peer to peer）模型。该模型的特点是，一个队列中的所有消息，会被一个消费者消费，且只能被该消费者消费一次。
- 主题（topic）模型：也叫发布-订阅（publish-subscribe）模型。该模型的特点是，一个主题的消息，可以被多个订阅了该主题的消费者消费，且每个消费者都会消费该主题下的全量消息。

另外，传统的消息系统中，消费者一般都是单个的消费实例，即消费者仅是一个线程，这与Kafka的消费者组有所区别。

### Kafka中的消息模型
Kafka中的消息模型，类似于传统的主题模型，但其扩展了消费者的概念，引入了消费者组（Consumer Group）。消费者组下包括多个消费者实例，整个消费者组作为一个消费者，共同消费所订阅主题下的所有消息。

## 关于重复消息的处理
对于消息的重复消费问题，需要消费端做对应的幂等处理。所谓的幂等处理，就是处理多次与处理一次的效果是一样的。有两种方案可以对消息进行幂等处理：

- 通过记录的状态处理重复消息。比如订单的状态为“未支付”，接收到支付消息後，更新状态为“已支付”。再次接收到重复的支付消息时，发现订单的状态为已支付，则忽略掉该消息。

- 通过全局唯一的字段来识别重复消息，这要求消息中必须带有的唯一标识字段，如订单ID等。这时可以将已处理消息的唯一标识字段保存起来，当有新消息来的时候，通过比对唯一标识字段，判断消息是否已消费。保存已消费消息的唯一标识字段的途径有多种：
  - 作为唯一健保存在数据库中：每次处理消息前，先将消息中的唯一字段插入表中，若出现唯一健冲突，则表明消息已被处理过。
  - 将唯一字段作为key保存在持久化缓存中：与保存在数据库中类似，根据缓存中是否存在该key，确定消息是否被重复处理。
  为了避免保存的key过多造成存储的浪费，可以根据消息的有效期（消息在Broker端一般不会永久保存下去），在确定消息已不会再次发送至消费者端後，定时地去清除数据库中保存的key，或者给缓存中的key设置有效期。



